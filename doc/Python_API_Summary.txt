1. Stack and Queue with list
stack = []
stack.append(5)
stack.append(4)

while stack: 
  a = stack.pop()       # 4 is popped from stack
  b = stack.pop()       # 5 is popped from stack

# deque에 비해 속도가 느리다.
queue = []
queue.append(5)
queue.append(4)

while queue: 
  a = queue.pop(0)       # 5 is popped from queue
  b = queue.pop(0)       # 4 is popped from queue

2. Queue
: deque가  list나 heapq에 비해 성능이 빠르다
1) deque 방법
from collections import deque
queue = deque()

queue.append(5)
queue.append(2)

while queue:
  a = queue.popleft() # 5 is popped from queue
  b = queue.popleft() # 2 is popped from queue

cf)
queue.reverse() # queue의 내부 원소들을 역순화

3. heapq 사용하기
import heapq

start = 1
q = []
heapq.heappush(q, (0, start))    # 첫번째 element ASC heap 구성. DESC heap은 원소에 -1을 곱해서 넣는 방식으로 구현

while q: # heapq가 비어있지 않다면
  distance, now = heapq.heappop(q)

4. 객체 Deep Copy  방법
import copy

tmp_key = copy.deepcopy(key)

5. map을 list로 만들기
food_storage = list(map(int, input().split()))

6. Dictionary
dic = {}
dic['파이썬'] = 'www.python.org'
dic['마이크로소프트'] = 'www.microsoft.com'

print(dic)
결과:  {'파이썬': 'www.python.org', '마이크로소프트': 'www.microsoft.com'}

print(list(dic.keys()))
결과: ['파이썬', '마이크로소프트']

print(list(dic.values()))
결과: ['www.python.org', 'www.microsoft.com']

print('파이썬' in dic.keys())
결과: True

print('www.python.org' in dic.values())
결과: True

dic.clear()
print(dic) 
결과: {}

7. list 관련 API
a = [1, 2, 3, 4, 5]
a.sort(reverse=True)  // 역순으로 정렬. a의 내용이 바뀜.

8. set 관련 API
head = [a, b, c]
tail = [d, b, c]
permute_set = set()
permute_set.add(tuple(head + tail)) // SET은 변경가능한 type인 list에서는 불가능.

9. 문자열 조작
a = 'Hello'
b = 'World'
c = a + ' ' + b # 'Hello World'

a = 'String'
print(a * 3) # 'StringStringString'
print(len(a*3)) # 8

a = 'ABCDEF'
print(a[2:4]) # CD

# 빈문자열 초기화
u = ''
v = ''

# for loop with string
u = '()))))((()'
for k in u[1:len(u)-1]:
  if k == '(':
    a += ')'
  else:
    a += '('

# count
a = 'Hello'
print(a.count('l')) # 2


8. 순열
from itertools import permutations
a = [1,2,3]
b = permutations(a,2)
print(list(b))

결과: [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]

9. 조합
from itertools import combinations
a = [1,2,3]
b = combinations(a,2)
    
print(list(b))

결과: [(1,2),(1,3),(2,3)]

10. Binary Search 관련
1) bisect() : 오름차순으로 정렬된 시퀀스에 x값이 들어갈 위치를 리턴한
import bisect
 
sequence = [1, 3, 4, 5]
 
print(bisect.bisect(sequence, 2))
---------------------------------
1

2) bisect_right(), bisect_left() :
 bisect_right()는 x와 동일한 값이 시퀀스 a에 존재할 때 x와 동일한 값 바로 뒤 위치를 리턴
 bisect_left()는 x와 동일한 값 위치를 리턴한다.

import bisect
 
sequence = [1, 3, 4, 5]
 
print(bisect.bisect_right(sequence, 3))
print(bisect.bisect_left(sequence, 3))
----------------------------------------
2
1

11. 2차원 Sort
import operator

a = [[0, 3], [1, 9], [2, 6]]
a.sort(key=operator.itemgetter(0, 1)) # 0번째 element에 의해 먼저 sort후, 1번째 element에 의해 sort
a.sort(key=operator.itemgetter(0, 1), reverse=True) # 0번째 element에 의해 먼저 desc sort후, 1번째 element에 의해 desc sort
a.sort(reverse=True) # 내림차순

12. 이차원 리스트 생성하기
graph = [[] for i in range(n + 1)] # [[], [], [], ... []] 최단거리 그래프 알고리즘에서 사용
visitied = [False] * (n + 1) # [False, False, False....]
a = [[0] *  3 for _ in range(10)] #[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], ....]

13. 두개의 리스트 합치기
a = [1, 2, 3, 4]
b = [5, 6, 7]
c = 5
d = a + b + [c]

14. print함수에서 라인 종료자가 아닌 다른 것을 사용하고 싶을 때
print("{}".format(from_node), end=' ') # 끝이 new line이 아니라, 공백 ' '사용

15. Global Variable (일반적으로 list는 자동으로 연결됨)
globvar = 0

def set_globvar_to_one():
    global globvar    # Needed to modify global copy of globvar
    globvar = 1

def print_globvar():
    print(globvar)     # No need for global declaration to read value of globvar

set_globvar_to_one()
print_globvar()       # Prints 

16. 빠른 입력 받기
import sys

input = sys.stdin.readline
n, m = map(int, input().split())



